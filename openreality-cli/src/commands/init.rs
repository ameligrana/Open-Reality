use std::path::Path;

use uuid::Uuid;

pub async fn run(name: String, engine_dev: bool, repo_url: String) -> anyhow::Result<()> {
    let project_dir = Path::new(&name);

    if project_dir.exists() {
        anyhow::bail!("Directory '{}' already exists.", name);
    }

    if engine_dev {
        run_engine_dev(&name, &repo_url).await
    } else {
        run_user_project(&name, &repo_url).await
    }
}

async fn run_engine_dev(name: &str, repo_url: &str) -> anyhow::Result<()> {
    println!("Cloning OpenReality for engine development...");

    let status = tokio::process::Command::new("git")
        .args(["clone", repo_url, name])
        .stdin(std::process::Stdio::inherit())
        .stdout(std::process::Stdio::inherit())
        .stderr(std::process::Stdio::inherit())
        .status()
        .await?;

    if !status.success() {
        anyhow::bail!("git clone failed (exit code: {:?})", status.code());
    }

    println!("Installing Julia dependencies...");
    run_julia_setup(Path::new(name), None).await;

    println!("\nEngine dev project ready! cd into '{}' and run `orcli`.", name);
    Ok(())
}

async fn run_user_project(name: &str, repo_url: &str) -> anyhow::Result<()> {
    let project_dir = Path::new(name);

    // Create directory structure
    println!("Creating project '{}'...", name);
    std::fs::create_dir_all(project_dir.join("scenes"))?;
    std::fs::create_dir_all(project_dir.join("assets"))?;
    std::fs::create_dir_all(project_dir.join(".openreality"))?;

    // Clone engine into engine/ subdirectory
    println!("Cloning OpenReality engine...");
    let status = tokio::process::Command::new("git")
        .args(["clone", "--depth", "1", repo_url, &format!("{name}/engine")])
        .stdin(std::process::Stdio::inherit())
        .stdout(std::process::Stdio::inherit())
        .stderr(std::process::Stdio::inherit())
        .status()
        .await?;

    if !status.success() {
        anyhow::bail!("git clone failed (exit code: {:?})", status.code());
    }

    // Write .openreality/config.toml
    let config_content = r#"# OpenReality project configuration
# Generated by orcli init

# Path to the OpenReality engine (relative to project root)
engine_path = "engine"

# Default backend for running scenes (optional)
# default_backend = "opengl"
"#;
    std::fs::write(
        project_dir.join(".openreality").join("config.toml"),
        config_content,
    )?;

    // Write Project.toml
    let project_uuid = Uuid::new_v4();
    let capitalized_name = capitalize_first(name);
    let project_toml = format!(
        r#"name = "{capitalized_name}"
uuid = "{project_uuid}"
version = "0.1.0"

[deps]
OpenReality = "b08b1914-4d33-46de-8c63-ba029b7f1c5f"
"#
    );
    std::fs::write(project_dir.join("Project.toml"), project_toml)?;

    // Write starter scene
    let scene_content = generate_starter_scene(name);
    std::fs::write(project_dir.join("scenes").join("main.jl"), scene_content)?;

    // Write assets/.gitkeep
    std::fs::write(project_dir.join("assets").join(".gitkeep"), "")?;

    // Run Pkg.develop + Pkg.instantiate
    println!("Installing Julia dependencies...");
    run_julia_setup(
        project_dir,
        Some(r#"Pkg.develop(path="engine"); Pkg.instantiate()"#),
    )
    .await;

    println!("\nProject '{}' is ready!", name);
    println!("  cd {}", name);
    println!("  orcli              # launch TUI dashboard");
    println!("  orcli run scenes/main.jl  # run the starter scene");
    Ok(())
}

async fn run_julia_setup(project_dir: &Path, extra_expr: Option<&str>) {
    let expr = match extra_expr {
        Some(e) => format!(r#"using Pkg; Pkg.activate("."); {e}"#),
        None => r#"using Pkg; Pkg.activate("."); Pkg.instantiate()"#.to_string(),
    };

    let result = tokio::process::Command::new("julia")
        .args(["--project=.", "-e", &expr])
        .current_dir(project_dir)
        .stdin(std::process::Stdio::inherit())
        .stdout(std::process::Stdio::inherit())
        .stderr(std::process::Stdio::inherit())
        .status()
        .await;

    match result {
        Ok(status) if status.success() => {
            println!("Julia dependencies installed successfully.");
        }
        Ok(status) => {
            eprintln!(
                "Warning: Julia setup exited with code {:?}. You may need to run manually:",
                status.code()
            );
            eprintln!("  cd {} && julia --project=. -e '{}'", project_dir.display(), expr);
        }
        Err(e) => {
            eprintln!("Warning: Julia not found ({}). Install Julia and run:", e);
            eprintln!("  cd {} && julia --project=. -e '{}'", project_dir.display(), expr);
        }
    }
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().to_string() + chars.as_str(),
    }
}

fn generate_starter_scene(project_name: &str) -> String {
    format!(
        r#"# {project_name} - Main Scene
# Generated by orcli init

using OpenReality

reset_entity_counter!()
reset_component_stores!()

s = scene([
    # Player with FPS controls (WASD + mouse look)
    create_player(position=Vec3d(0, 1.7, 5)),

    # Directional light (sun)
    entity([
        DirectionalLightComponent(
            direction=Vec3f(0.3, -1.0, -0.5),
            intensity=2.0f0
        )
    ]),

    # Floor
    entity([
        plane_mesh(width=20.0f0, depth=20.0f0),
        MaterialComponent(
            color=RGB{{Float32}}(0.5, 0.5, 0.5),
            metallic=0.0f0,
            roughness=0.9f0
        ),
        transform(),
        ColliderComponent(shape=AABBShape(Vec3f(10.0, 0.01, 10.0)), offset=Vec3f(0, -0.01, 0)),
        RigidBodyComponent(body_type=BODY_STATIC)
    ]),

    # A cube to get started
    entity([
        cube_mesh(),
        MaterialComponent(
            color=RGB{{Float32}}(0.2, 0.6, 0.9),
            metallic=0.3f0,
            roughness=0.4f0
        ),
        transform(position=Vec3d(0, 0.5, 0)),
        ColliderComponent(shape=AABBShape(Vec3f(0.5, 0.5, 0.5))),
        RigidBodyComponent(body_type=BODY_STATIC)
    ])
])

@info "Scene created with $(entity_count(s)) entities"
render(s)
"#
    )
}
